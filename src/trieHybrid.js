let HybridModel = require("./hybridModel.js");
let LoopHybridModel = require("./loopHybridModel.js");
let ListSymbolicModel = require("./listSymbolicModel.js");

module.exports = class TrieHybrid {
  
  constructor(symbolicWrapper, numLetters) {
	this.root = null;
	this.symbolicWrapper = symbolicWrapper;
	this.numLetters = numLetters;
  }
  
  // TODO: More methods: insert
  
  async search(key) {
	// TrieHybrid.virtualTime = 0;
	// Boring one by one initialization of variables
	var stack = [];
	stack[0] = key;  // key word
	stack[1] = this.root;  // currentAlphaLetterIndex - 0-26 Alphabet size
	stack[2] = 0;  // currentTrieNodeId - most unique
	//stack[3] = key.length; //length - least unique < key.length
	stack[3] = false;  // Loop result
	stack[4] = false;  // Function result
	var self = this;
	var height = 0;
	
	// // Initialize the word
	// stack[0] = new ListSymbolicModel(stack[0]);
	// // Run the loop
	// stack[3] = (new LoopHybridModel(...)).Run();
	// // NodeId found check
	// return false if stack[3] == false
	// // NodeEnd found check
	// return false if nodeEnd(stack[2]) == false
	// default: return true;
	let result = (await (new HybridModel({
			model: {
				sequence: "SearchSequence",
				method:  "SearchMethod",
				argument:  "SearchArg",
				result: "SearchResult",
			},
			stack: stack,
			result: 4,
			symbolicWrapper: self.symbolicWrapper,
			symbolicFunctions: {
				getWordInit: async function(stack, args) {
					// Convert, string, ListSymbolicModel
					// Initialize Word;
					// Return/Destination = Symbolic model(args/Source)
					// genericSymbolicModel("getWordInit", stack, 0, [0]);
					return new ListSymbolicModel(stack[args[0]]);
					
					// Where things go in memory are not as relevant as what runs and its args, except for the resultError destination.
				},
				getSearchLoop: async function(stack, args) {
					// genericSymbolicModel("getSearchLoop", stack, 3, []);
				
					// // Gets the next letter 
					// // This one is a symbolic model, it feeds the letters of the word to loop
					// stack[1] = stack[0].get();
					
					// // Report failure to find an entry
					// if (stack[1] == false)
						// return stack[3];
					
					// // Converts the next letter to the index
					// stack[1] = (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(stack[1]) - 'a'.charCodeAt(0);
					
					// // Assign the current trie state to the child node
					// // stack[1].children[stack[2]];
					// // This one is a Gradient Boosted Model, it feeds the trie to the loop
					// stack[2] = SymbolicWrapper.Get(["TrieModel", stack[2], stack[1]]);
					
					// // Report failure to find an entry
					// if (stack[2] == false)
						// return stack[3];
					
					// stack[3] = true;
					// return stack[3];
					await (new LoopHybridModel({
						stack: stack,
						result: 3,
						symbolicWrapper: self.symbolicWrapper,
						loopCallback: async function() {							
							return (await (new HybridModel({
								model: {
									sequence: "SearchLoopSequence",
									method:  "SearchLoopMethod",
									argument:  "SearchLoopArg",
									result: "SearchLoopResult",
								},
								stack: stack,
								result: 3,
								symbolicWrapper: self.symbolicWrapper,
								symbolicFunctions: {
									// PRECONDITIONS
									getNextLetter: async function(stack, args) {
										// Get the word's next letter
										// Next, List<LetterChar>, LetterChar
										// Return/Destination = Symbolic model(args/Source)
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getNextLetter", stack, 1, [0])
										return stack[args[0]].next();
									},
									getCheckFalse: async function(stack, args) {
										// TODO: REPEAT
										// Making Argument not nullable
										// IsFalse, LetterChar?, Bool
										// Return/Destination = Symbolic model(args/Source)
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getCheckFalse", stack, resultError, [1])
										return !stack[args[0]];
									},
									// LOGIC
									getFalse: async function(stack, args) {
										// Clear the result memory in a loop, after the preconditions have passed.
										// false, String, Bool
										// To be updaded at the end of the function as well conditionally on success.
										// Return/Destination = Symbolic model(args/Source)
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getFalse", stack, 3, [])
										return false;
									},
									getLetterIndex: async function(stack, args) {
										// HOW COULD THIS BE AUTO-GENERATED BY THE PRODUCTION RULE SYSTEM? 
										// Just a routine conversion. Based on simulated current state of the stack and meta-production rules based on stack state + Types.
										// GOAL: to be able to run the next step of getNextNodeId
										// Convert, LetterChar, LetterIndex
										// Return/Destination = Symbolic model(args/Source)
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getLetterIndex", stack, 1, [1])
										return (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(stack[args[0]]) - 'a'.charCodeAt(0);
									},
									getNextNodeId: async function(stack, args) {
										// Get next nodeId in the trie using the letter index
										// Get, TrieModel, NodeId, LetterIndex, NodeId
										// Return/Destination = Symbolic model(args/Source): 
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getNextNodeId", stack, 2, [2,1])
										var result;
										try {
											result = await self.symbolicWrapper.Get([`TrieModel${self.numLetters}`, stack[args[0]], stack[args[1]]]);
										}
										catch (error) {
											result = null;
										}
										
										return result;
									},
									// POSTCONDITIONS
									// genericSymbolicModel("getCheckFalse", stack, resultError, [2])
									getExchaustiveCheck: async function(stack, args) {
										// Get next nodeId in the trie using the letter index
										// Get, TrieModel, NodeId, LetterIndex, NodeId
										// Return/Destination = Symbolic model(args/Source): 
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getExchaustiveCheck", stack, resultError, [2, 1])
										let result;
										let check;
										try {
											check = await self.symbolicWrapper.Get([`TrieCheck${self.numLetters}`, stack[args[0]]]);
										}
										catch (error) {
											check = null;
										}
										
										result = check != stack[args[1]];
										if (!result) {
											height++;
										}
										
										return result;
									},
									getTrue: async function(stack, args) {
										// Returns the constant false
										// true, Bool
										// Updaded at the end of the function as well conditionally on success.
										// Return/Destination = Symbolic model(args/Source)
										// Could solve the following problem by dependency injection(DI)
										// genericSymbolicModel("getTrue", stack, 3, [])
										return true;
									}
								}
							})).Run()).resultError;
						}
					})).Run();

					return false;
				},
				getCheckFalse: async function(stack, args) {
					// Making Argument not nullable
					// IsFalse, LetterChar?, Bool
					// Return/Destination = Symbolic model(args/Source)
					// Could solve the following problem by dependency injection(DI)
					// genericSymbolicModel("getCheckFalse", stack, resultError, [3])
					return !stack[args[0]];
				},
				getNodeEndCheck: async function(stack, args) {
					// Check the NodeEnd model for the end of the word'
					//
					// If I had stack support here instead of control flow, I could reuse this.getCheckFalse;
					// Or I could break this into one step saving it on the stack, second step getCheckFalse.
					// Doing the more dirty symbolic representation is fine for this first prototype.
					// 
					// Next, TrieEndModel, NodeId, bool
					// Return/Destination = Symbolic model(args/Source)
					// Could solve the following problem by dependency injection(DI)
					// genericSymbolicModel("getNodeEndCheck", stack, resultError, [2])
					return await self.symbolicWrapper.Get([`TrieEnd${self.numLetters}`, stack[args[0]]]) == "FALSE";

				},
				getTrue: async function(stack, args) {
					// Returns the constant true
					// true, String, Bool, result, args
					// Updaded at the end of the function as well conditionally on success.
					// Return/Destination = Symbolic model(args/Source)
					// Could solve the following problem by dependency injection(DI)
					// genericSymbolicModel("getPositiveResult", stack, 4, [])
					return true;
				}
			}
		})).Run()).result;
		
		return {
			found: result,
			height: height
		};
		
  }
}
